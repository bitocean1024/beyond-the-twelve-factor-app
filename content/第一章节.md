# <center>CHAPTER 1</center>

### Once Codebase,One Application

第一个原始的因素是：代码仓库（codebase）,原始的说法是：“一个版本最终的代码仓库，多份部署”

当需要管理一个开发团队的各个方面的时候，代码的组织，组件的管理等细节通常都会被忽略掉。但是合理的应用准则和管理应该能够明确出来“按月开发”和“按天开发”的产品在代码管理上的区别

云原生应用必须一直存在与一个版本管理系统的代码仓库，一个代码仓库是一个版本控制系统的repository或者一批repository但是共享相同的库根

单个应用的仓库代码被用于产生许多不可变的被部署于不同环境的release。遵守这个准则能够迫使团队成员去分析他们的应用边界以及可能分析是否存在一些单体服务应该被拆分成多个微服务。如果你的一个应用有多个代码仓库，可能你的系统需要被解耦合了，而不应该是一个单体应用

>1、一个不可变的release是一个构建出来的组件，这个组件是不可变的，这一点将会在本书的后面多次提及，这种类型的组件需要被测试，确保dev/prod环境相同，提前预测部署结果

>2、在微服务拆分上可以参考Building Microservices by Sam Newman (O’Reilly) 获取更多的指导

最简单的违反这条准则的例子就是你的应用确实是由多个代码仓库组成的，这样的做法让你的应用的构建和部署阶段几乎不可能做到自动化

另外一个经常打破这条准则的的方式是一个主应用和一个紧耦合的worker(or an en-queuer and de-queuer,etc 不知道该怎么翻译这个)，两者一起合作完成一项工作。在这种场景下，确实是多个代码仓库支持一个应用，尽管他们共享一个根目录。这就是为什么我认为代码仓库这个概念应该是表明一个有凝聚力的单元，而不是仅仅一个版本控制系统的repository

相反的，当一个代码仓库被用于产生多个应用的时候，这条准则依然会是被打破了。举个例子，一个代码仓库是一个包装模块，但是包装模块确是由多个启动脚本或者由多个不同时间点执行的脚本组成。在Java厘米，EAR包是一个打破 One Codebase的毒药，在解释语言的世界里（e.g.，Ruby）,你可能会在一个codebase里面包含多个启动脚本，每个脚本干了完全不同的事情

多个应用在一个仓库通常是一种迹象，这个迹象表明可能是多个不同的团队维护了相同的codebase，这种方式后续将会由于各种原因变得很丑陋。康威定律表明组织架构最终会反应到产品架构里面，换句话说，功能紊乱的差劲的组织架构，缺乏秩序的团队通常会导致功能紊乱和缺乏秩序的代码

如果你确实面临着多个团度维护一个代码仓库，你可能需要利用康威定律把你大的团队拆分称小的团队，每个小团队去独立负责自己的应用或者说是微服务

如果你审视你的应用并且决定找机会重构你的代码仓库成为一个个小的产品，你会发现多个仓库对应的一个应用可能可以被拆分称一个一个微服务，微服务通过暴露API能够被其他应用所复用

换句话说“一个代码仓库，一个应用”并不是说不允许你在多个应用中共享代码，它仅仅意味着你的共享代码应该是一个单独的仓库

这条准则也不是说所有共享的代码都需要成为一个微服务，准确的说，你需要评估你的共享代码是否应该被拆分成一个独立发布的产品，这个产品以供应商的身份作为你的应用的一个依赖

### 项目主页
* [beyond-twelve-factors-app 中文版](../README.md)
